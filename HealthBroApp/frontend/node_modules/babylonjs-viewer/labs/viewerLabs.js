"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environmentSerializer_1 = require("./environmentSerializer");
var math_1 = require("babylonjs/Maths/math");
var sphericalPolynomial_1 = require("babylonjs/Maths/sphericalPolynomial");
var texture_1 = require("./texture");
/**
 * The ViewerLabs class will hold functions that are not (!) backwards compatible.
 * The APIs in all labs-related classes and configuration  might change.
 * Once stable, lab features will be moved to the publis API and configuration object.
 */
var ViewerLabs = /** @class */ (function () {
    function ViewerLabs(_scene) {
        this._scene = _scene;
        this.environment = {
            //irradiance
            irradiancePolynomialCoefficients: {
                x: new math_1.Vector3(0, 0, 0),
                y: new math_1.Vector3(0, 0, 0),
                z: new math_1.Vector3(0, 0, 0),
                xx: new math_1.Vector3(0, 0, 0),
                yy: new math_1.Vector3(0, 0, 0),
                zz: new math_1.Vector3(0, 0, 0),
                yz: new math_1.Vector3(0, 0, 0),
                zx: new math_1.Vector3(0, 0, 0),
                xy: new math_1.Vector3(0, 0, 0)
            },
            textureIntensityScale: 1.0
        };
    }
    ViewerLabs.prototype.loadEnvironment = function (data, onSuccess, onProgress, onError) {
        var _this = this;
        //@! todo: should loadEnvironment cancel any currently loading environments?
        if (data instanceof ArrayBuffer) {
            this.environment = environmentSerializer_1.EnvironmentDeserializer.Parse(data);
            if (onSuccess) {
                onSuccess(this.environment);
            }
        }
        else if (typeof data === 'string') {
            var url = this.getAssetUrl(data);
            this._scene._loadFile(url, function (arrayBuffer) {
                _this.environment = environmentSerializer_1.EnvironmentDeserializer.Parse(arrayBuffer);
                if (onSuccess) {
                    onSuccess(_this.environment);
                }
            }, function (progressEvent) { if (onProgress) {
                onProgress(progressEvent.loaded, progressEvent.total);
            } }, false, true, function (r, e) {
                if (onError) {
                    onError(e);
                }
            });
        }
        else {
            //data assumed to be PBREnvironment object
            this.environment = data;
            if (onSuccess) {
                onSuccess(data);
            }
        }
    };
    /**
     * Applies an `EnvironmentMapConfiguration` to the scene
     * @param environmentMapConfiguration Environment map configuration to apply
     */
    ViewerLabs.prototype.applyEnvironmentMapConfiguration = function (rotationY) {
        if (!this.environment) {
            return;
        }
        //set orientation
        var rotatquatRotationionY = math_1.Quaternion.RotationAxis(math_1.Axis.Y, rotationY || 0);
        // Add env texture to the scene.
        if (this.environment.specularTexture) {
            // IE crashes when disposing the old texture and setting a new one
            if (!this._scene.environmentTexture) {
                this._scene.environmentTexture = texture_1.TextureUtils.GetBabylonCubeTexture(this._scene, this.environment.specularTexture, false, true);
            }
            if (this._scene.environmentTexture) {
                this._scene.environmentTexture.level = this.environment.textureIntensityScale;
                this._scene.environmentTexture.invertZ = true;
                this._scene.environmentTexture.lodLevelInAlpha = true;
                var poly = this._scene.environmentTexture.sphericalPolynomial || new sphericalPolynomial_1.SphericalPolynomial();
                poly.x = this.environment.irradiancePolynomialCoefficients.x;
                poly.y = this.environment.irradiancePolynomialCoefficients.y;
                poly.z = this.environment.irradiancePolynomialCoefficients.z;
                poly.xx = this.environment.irradiancePolynomialCoefficients.xx;
                poly.xy = this.environment.irradiancePolynomialCoefficients.xy;
                poly.yy = this.environment.irradiancePolynomialCoefficients.yy;
                poly.yz = this.environment.irradiancePolynomialCoefficients.yz;
                poly.zx = this.environment.irradiancePolynomialCoefficients.zx;
                poly.zz = this.environment.irradiancePolynomialCoefficients.zz;
                this._scene.environmentTexture.sphericalPolynomial = poly;
                //set orientation
                math_1.Matrix.FromQuaternionToRef(rotatquatRotationionY, this._scene.environmentTexture.getReflectionTextureMatrix());
            }
        }
    };
    /**
     * Get an environment asset url by using the configuration if the path is not absolute.
     * @param url Asset url
     * @returns The Asset url using the `environmentAssetsRootURL` if the url is not an absolute path.
     */
    ViewerLabs.prototype.getAssetUrl = function (url) {
        var returnUrl = url;
        if (url && url.toLowerCase().indexOf("//") === -1) {
            if (!this.assetsRootURL) {
                // Tools.Warn("Please, specify the root url of your assets before loading the configuration (labs.environmentAssetsRootURL) or disable the background through the viewer options.");
                return url;
            }
            returnUrl = this.assetsRootURL + returnUrl;
        }
        return returnUrl;
    };
    ViewerLabs.prototype.rotateShadowLight = function (shadowLight, amount, point, axis, target) {
        if (point === void 0) { point = math_1.Vector3.Zero(); }
        if (axis === void 0) { axis = math_1.Axis.Y; }
        if (target === void 0) { target = math_1.Vector3.Zero(); }
        axis.normalize();
        point.subtractToRef(shadowLight.position, math_1.Tmp.Vector3[0]);
        math_1.Matrix.TranslationToRef(math_1.Tmp.Vector3[0].x, math_1.Tmp.Vector3[0].y, math_1.Tmp.Vector3[0].z, math_1.Tmp.Matrix[0]);
        math_1.Tmp.Matrix[0].invertToRef(math_1.Tmp.Matrix[2]);
        math_1.Matrix.RotationAxisToRef(axis, amount, math_1.Tmp.Matrix[1]);
        math_1.Tmp.Matrix[2].multiplyToRef(math_1.Tmp.Matrix[1], math_1.Tmp.Matrix[2]);
        math_1.Tmp.Matrix[2].multiplyToRef(math_1.Tmp.Matrix[0], math_1.Tmp.Matrix[2]);
        math_1.Tmp.Matrix[2].decompose(math_1.Tmp.Vector3[0], math_1.Tmp.Quaternion[0], math_1.Tmp.Vector3[1]);
        shadowLight.position.addInPlace(math_1.Tmp.Vector3[1]);
        shadowLight.setDirectionToTarget(target);
    };
    return ViewerLabs;
}());
exports.ViewerLabs = ViewerLabs;
//# sourceMappingURL=viewerLabs.js.map